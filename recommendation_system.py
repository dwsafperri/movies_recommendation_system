# -*- coding: utf-8 -*-
"""recommendation_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tm_l21EPYX_yT1kiOj8VTIONptBa40hH

# **Movies Recommendation System**

- **Nama**: Dewi Safira Permata sari
- **Email**: dwsafperri@gmail.com
- **ID Dicoding**: dwsafperri

# **Project Overview**

Dengan terus bertambahnya jumlah film yang tersedia di berbagai platform digital, pengguna sering kesulitan menemukan film yang sesuai dengan selera mereka. Salah satu pendekatan populer untuk mengatasi permasalahan ini adalah sistem rekomendasi berbasis konten (*content-based filtering*), di mana rekomendasi diberikan berdasarkan kesamaan karakteristik konten — dalam hal ini, genre film.

Proyek ini bertujuan membangun **sistem rekomendasi film berdasarkan genre** menggunakan pendekatan content-based filtering. Misalnya, jika seorang pengguna menyukai film King Kong, maka sistem akan merekomendasikan film lain yang memiliki genre serupa seperti Action, Adventure, atau Horror.

Sistem ini relevan karena membantu pengguna mengeksplorasi film yang mungkin belum pernah mereka tonton namun memiliki karakteristik yang mereka sukai. Selain itu, pendekatan ini tidak memerlukan data interaksi pengguna lain, sehingga cocok untuk kondisi cold start atau sistem baru.

# **Business Understanding**

## **Problem Statements**

1. Bagaimana cara merepresentasikan informasi genre film secara numerik agar bisa digunakan dalam perhitungan kemiripan antar film?

2. Bagaimana cara mengukur tingkat kemiripan antar film hanya berdasarkan informasi kontennya, khususnya genre?

3. Bagaimana cara mengembangkan sistem rekomendasi film yang mampu memberikan saran film sejenis hanya dari satu input judul film?

## **Goals**

1. Menghasilkan sistem rekomendasi film yang mampu menyarankan film lain dengan genre yang mirip dari input satu judul film.

2. Memudahkan pengguna menemukan film-film baru sesuai dengan preferensi genre mereka tanpa perlu memberikan penilaian eksplisit.

3. Membuat sistem yang bersifat general dan bisa digunakan tanpa ketergantungan pada data pengguna (user rating history).

## **Solution Statements**

1. Menggunakan pendekatan content-based filtering dengan teknik TF-IDF vectorization untuk merepresentasikan genre film.

2. Mengukur kemiripan antar film menggunakan cosine similarity untuk menentukan film-film yang memiliki kemiripan konten.

3. Mengimplementasikan fungsi rekomendasi yang menerima judul film sebagai input dan menghasilkan daftar rekomendasi berdasarkan tingkat kemiripan genre.

# **Data Understanding**

## **1. Import Library**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import ast

import warnings
warnings.filterwarnings('ignore')

"""## **2. Load Dataset**"""

#!/bin/bash
!curl -L -o the-movies-dataset.zip\
  'https://www.kaggle.com/api/v1/datasets/download/rounakbanik/the-movies-dataset'

!unzip -q the-movies-dataset.zip

"""### Deskripsi Variabel

"""

data_ratings = pd.read_csv("/content/ratings.csv")
data_ratings.info()

"""**Insight :**

Data ratings memiliki 26.024.289 baris dan 4 fitur.

| **Kolom**   | **Deskripsi**                                                                 |
| ----------- | ----------------------------------------------------------------------------- |
| `userId`    | ID pengguna yang memberikan rating.                                           |
| `movieId`   | ID film yang diberi rating.                                                   |
| `rating`    | Nilai rating yang diberikan oleh pengguna (biasanya skala 1.0–5.0).           |
| `timestamp` | Waktu pemberian rating dalam format Unix timestamp (jumlah detik sejak 1970). |

Dikarenakan jumlah data yang terlalu banyak, maka data yang diambil hanya 10.000 data.

"""

ratings = data_ratings.sample(n=10000, random_state=42)
ratings.shape

"""**Insight :**

Data ratings berhasil di filter sebanyak 10.000 data.
"""

data_movies = pd.read_csv("/content/movies_metadata.csv")
data_movies.info()

"""**Insight :**

Data movies memiliki 45.466 baris dan 24 kolom.

| **Kolom**               | **Deskripsi**                                             |
| ----------------------- | --------------------------------------------------------- |
| `adult`                 | Menandakan apakah film untuk dewasa (`True`/`False`).     |
| `belongs_to_collection` | Informasi jika film bagian dari seri/koleksi.             |
| `budget`                | Anggaran produksi film (biasanya dalam USD).              |
| `genres`                | Daftar genre film.                                        |
| `homepage`              | URL resmi film (jika tersedia).                           |
| `id`                    | ID unik film (dari TMDB).                                 |
| `imdb_id`               | ID film di IMDb.                                          |
| `original_language`     | Bahasa asli film (contoh: `en` untuk Inggris).            |
| `original_title`        | Judul asli film.                                          |
| `overview`              | Ringkasan atau sinopsis film.                             |
| `popularity`            | Skor popularitas dari TMDB.                               |
| `poster_path`           | Path ke poster film.                                      |
| `production_companies`  | Daftar perusahaan produksi.                               |
| `production_countries`  | Negara tempat film diproduksi.                            |
| `release_date`          | Tanggal rilis film.                                       |
| `revenue`               | Pendapatan film (dalam USD).                              |
| `runtime`               | Durasi film dalam menit.                                  |
| `spoken_languages`      | Bahasa yang digunakan dalam film.                         |
| `status`                | Status rilis film (misal: `Released`, `Post Production`). |
| `tagline`               | Slogan atau tagline film.                                 |
| `title`                 | Judul film (umumnya untuk keperluan tampilan).            |
| `video`                 | Apakah data ini berupa video (`True`/`False`).            |
| `vote_average`          | Rata-rata rating dari pengguna.                           |
| `vote_count`            | Jumlah total suara (rating) yang masuk.                   |

Dikarenakan jumlah data yang terlalu banyak, maka data yang diambil hanya 10.000 data.
"""

movies = data_movies.sample(n=10000, random_state=42)
movies.shape

print('Jumlah data ratings: ', len(ratings.userId.unique()))
print('Jumlah data movies yang direview: ', len(movies.id.unique()))

"""**Insight :**

Data movies berhasil di filter sebanyak 10.000 data.

### Deskripsi Statistik
"""

ratings.describe()

"""**Insight :**

| **Kolom**     | **Insight Utama**                                                                                                                                        |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **userId**    | - 10.000 data unik dengan userId rata-rata 135.302, rentang luas (8 – 270.761) <br> - Variasi user tinggi, artinya banyak user berbeda                   |
| **movieId**   | - Rentang sangat luas (1 – 174.615), rata-rata 16.095 <br> - Kuartil bawah jauh lebih kecil dari max, menunjukkan distribusi tidak merata (skewed)       |
| **rating**    | - Rata-rata 3.53 dengan rentang 0.5 – 5 <br> - Sebagian besar rating di 3 – 4 (median 3.5), menunjukkan rating cenderung positif                         |
| **timestamp** | - Rentang waktu cukup luas (sekitar 825 juta – 1,5 miliar UNIX timestamp) <br> - Distribusi waktu data merata, artinya pengambilan data berlangsung lama |

"""

movies.describe()

"""**Insight :**

| **Kolom**         | **Insight Utama**                                                                                                                                                                                                                                                                      |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **revenue**       | - Rata-rata sekitar 10.7 juta, tapi sangat bervariasi (std \~57 juta) <br> - 75% film punya revenue 0, artinya banyak film yang tidak menghasilkan pendapatan tercatat (atau nol) <br> - Maksimum sangat besar, mencapai 1,16 miliar, ada beberapa blockbuster saja yang sangat tinggi |
| **runtime**       | - Rata-rata durasi film sekitar 94 menit <br> - Rentang durasi cukup luas, dari 0 (mungkin data hilang/tidak valid) sampai 900 menit <br> - Kuartil menunjukkan mayoritas film berdurasi antara 85 sampai 107 menit                                                                    |
| **vote\_average** | - Rata-rata rating suara film 5.61 (skala 0–10) <br> - Sebagian besar film mendapat nilai sekitar 5–7 <br> - Nilai maksimum 10, nilai minimum 0 (mungkin film yang belum mendapat vote)                                                                                                |
| **vote\_count**   | - Rata-rata jumlah vote 107, tapi distribusi sangat skewed (std 464) <br> - Banyak film dengan vote rendah (kuartil 25% = 3), beberapa film sangat populer dengan hingga 12.269 vote                                                                                                   |

## **3. Exploratory Data Analysis**

### **a. Distribusi Rating**
"""

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8,4))
sns.histplot(ratings['rating'], bins=10, kde=True)
plt.title('Distribusi Rating Film')
plt.xlabel('Rating')
plt.ylabel('Frekuensi')
plt.show()

"""**Insight :**

1. **Sebaran Rating Tidak Merata (Right-skewed)**

   * Distribusi rating condong ke kanan, yang berarti lebih banyak film yang mendapatkan rating tinggi (antara 3 hingga 5).
   * Hanya sedikit film yang mendapat rating rendah (kurang dari 2).

2. **Rating Populer di Skor 3 dan 4**

   * Puncak tertinggi histogram (frekuensi paling besar) berada pada rating **3 dan 4**, menunjukkan bahwa sebagian besar pengguna memberikan rating di kisaran ini.

3. **Rating Sempurna (5) Juga Cukup Banyak**

   * Terlihat ada lonjakan lagi di rating **5**, menunjukkan bahwa cukup banyak pengguna yang memberikan nilai sempurna pada film tertentu.

4. **Rating Ekstrem (0 - 1) Sangat Jarang**

   * Frekuensi pada nilai rating mendekati 0 hampir tidak ada, artinya sangat sedikit film yang dianggap "buruk sekali" oleh penonton.

### **b. Distribusi Tahun Rilis Film**
"""

movies['release_date'] = pd.to_datetime(movies['release_date'], errors='coerce')
movies['release_year'] = movies['release_date'].dt.year

plt.figure(figsize=(10,5))
sns.histplot(movies['release_year'].dropna().astype(int), bins=50)
plt.title('Distribusi Tahun Rilis Film')
plt.xlabel('Tahun Rilis')
plt.ylabel('Jumlah Film')
plt.show()

"""**Insight :**


1. **Jumlah Film Meningkat Signifikan Setelah Tahun 1980-an**

   * Terlihat pertumbuhan tajam jumlah film mulai dari tahun 1980-an hingga puncaknya di sekitar tahun 2010–2015.
   * Hal ini mencerminkan kemajuan teknologi produksi, distribusi digital, dan platform streaming.

2. **Ledakan Produksi Film Era 2000-an**

   * Puncak tertinggi terjadi di rentang tahun **2010–2015**, dengan lebih dari 1.200 film dirilis per tahun.
   * Bisa jadi ini efek dari munculnya studio independen, kemudahan akses teknologi kamera, atau kemunculan platform seperti YouTube dan Netflix.

3. **Produksi Rendah di Awal Abad ke-20**

   * Produksi film sangat sedikit sebelum tahun 1950-an, yang wajar karena industri perfilman masih sangat baru saat itu.

4. **Penurunan di Akhir Distribusi (sekitar 2020)**

   * Ada penurunan tajam setelah 2015–2020. Ini kemungkinan disebabkan oleh:

     * **Data belum lengkap** (film baru belum semuanya masuk ke database).
     * **Pandemi COVID-19**, yang menyebabkan banyak produksi film tertunda atau dibatalkan.

5. **Distribusi Positively Skewed (Kanan)**

   * Sebagian besar data terkonsentrasi di era modern, menunjukkan tren meningkat seiring waktu.

### **c. Distribusi Runtime**
"""

plt.figure(figsize=(8,4))
sns.histplot(movies['runtime'].dropna(), bins=50)
plt.title('Distribusi Durasi Film (menit)')
plt.xlabel('Durasi (menit)')
plt.ylabel('Jumlah Film')
plt.show()

"""**Insight :**

1. **Mayoritas Film Berdurasi 80–120 Menit**

   * Puncak histogram berada di kisaran durasi tersebut, yang juga merupakan **durasi standar film bioskop**.
   * Ini menunjukkan bahwa sebagian besar film diproduksi dengan mempertimbangkan kenyamanan menonton.

2. **Distribusi Positively Skewed (Skew Kanan)**

   * Banyak film berdurasi normal (sekitar 100 menit), tapi ada **sedikit film dengan durasi sangat panjang**, bahkan di atas 300 menit.
   * Beberapa dari ini mungkin adalah film dokumenter, serial gabungan, atau data outlier.

3. **Outlier Durasi Ekstrem**

   * Ada film yang berdurasi **di atas 400–900 menit**, yang sangat tidak umum.
   * Bisa jadi itu:

     * Salah input (data error),
     * Film eksperimental,
     * Kompilasi/serial dimasukkan sebagai satu film.

4. **Durasi Kurang dari 40 Menit Juga Ada**

   * Ini kemungkinan merupakan film pendek atau special features.

### **d. Rating Rata-Rata per Film**
"""

avg_rating = ratings.groupby('movieId')['rating'].mean()

plt.figure(figsize=(8,4))
sns.histplot(avg_rating, bins=50, kde=True)
plt.title('Distribusi Rating Rata-rata per Film')
plt.xlabel('Rating Rata-rata')
plt.ylabel('Jumlah Film')
plt.show()

"""**Insight :**

1. **Distribusi Berbentuk Mendekati Normal, Tapi Tidak Sempurna**

   * Sebagian besar film memiliki rating rata-rata antara **2.5 hingga 4.0**, yang merupakan kisaran "cukup hingga bagus".
   * Puncak distribusi ada di sekitar **rating 3.5–4.0**, menandakan banyak film mendapatkan respons positif dari penonton.

2. **Pola Bar yang "Bergelombang"**

   * Ada lonjakan tajam di rating bulat seperti **3.0**, **4.0**, dan **5.0**.
   * Hal ini mengindikasikan:

     * Banyak penonton yang cenderung memberi rating bulat, bukan desimal.
     * Atau, rating rata-rata bulat terjadi karena banyak film memiliki jumlah rating sedikit.

3. **Film dengan Rating Sangat Rendah (1.0–2.0) Relatif Sedikit**

   * Ini menunjukkan bahwa sangat sedikit film yang dianggap buruk secara universal.
   * Bisa juga disebabkan karena film yang sangat buruk tidak banyak ditonton/rated.

4. **Ada Film dengan Rating Mendekati 5.0**

   * Menunjukkan bahwa ada beberapa film yang sangat disukai oleh penonton (cult classics atau masterpiece).

5. **Skewness Tidak Terlalu Ekstrem**

   * Distribusi relatif simetris dengan kecenderungan sedikit ke kanan, artinya film cenderung mendapat nilai lebih tinggi daripada rendah.

### **e. Korelasi Antar Fitur Numerik Film**
"""

# Hitung jumlah rating per film
ratings_count = ratings.groupby('movieId').size().rename('rating_count')

# Hitung rata-rata rating per film
avg_rating = ratings.groupby('movieId')['rating'].mean().rename('average_rating')

# Gabungkan ke movies_metadata pakai 'movieId' (pastikan ada kolom yang sama)
movies_subset = movies[['id', 'runtime', 'release_year']].copy()
movies_subset['id'] = movies_subset['id'].astype(str)

# Convert movieId ke string agar bisa merge
ratings_count.index = ratings_count.index.astype(str)
avg_rating.index = avg_rating.index.astype(str)

# Gabungkan semua data
df_corr = movies_subset.set_index('id').join([ratings_count, avg_rating])

# Drop baris dengan nilai NaN
df_corr = df_corr.dropna()

df_corr.head()

import seaborn as sns
import matplotlib.pyplot as plt

# Hitung korelasi
corr = df_corr.corr()

plt.figure(figsize=(8,6))
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Korelasi Antar Fitur Numerik Film')
plt.show()

"""**Insight :**

| Fitur 1        | Fitur 2          | Korelasi  | Interpretasi                                                                                                            |
| -------------- | ---------------- | --------- | ----------------------------------------------------------------------------------------------------------------------- |
| `runtime`      | `release_year`   | **0.09**  | Korelasi sangat lemah dan positif → film makin modern cenderung sedikit lebih panjang durasinya, tapi tidak signifikan. |
| `runtime`      | `average_rating` | **-0.06** | Korelasi sangat lemah dan negatif → durasi film tidak berpengaruh signifikan terhadap rating.                           |
| `release_year` | `average_rating` | **0.02**  | Hampir tidak ada hubungan antara tahun rilis dan rating. Film lama atau baru punya peluang yang sama untuk disukai.     |
| `rating_count` | `average_rating` | **0.04**  | Hampir tidak ada korelasi → jumlah rating tidak menunjukkan apakah film disukai atau tidak.                             |
| `runtime`      | `rating_count`   | **0.02**  | Tidak ada hubungan berarti antara panjang film dan seberapa banyak orang menontonnya.                                   |


- Semua fitur memiliki korelasi rendah (< 0.1) → artinya tidak ada hubungan linear kuat antar fitur numerik.
Ini menunjukkan bahwa:
  - Popularitas (jumlah rating) dan kualitas (rating rata-rata) tidak selalu berjalan beriringan.

  - Durasi film bukan indikator utama apakah film disukai atau tidak.

  - Tahun rilis juga bukan penentu utama untuk nilai atau popularitas film
"""

import pandas as pd

movies['popularity'] = pd.to_numeric(movies['popularity'], errors='coerce')

# Drop data yang popularity-nya kosong
movies_clean = movies.dropna(subset=['popularity'])

# Urutkan berdasarkan popularity tertinggi dan ambil top 10
top_10_movies = movies_clean.sort_values(by='popularity', ascending=False).head(10)

# Plot bar chart
plt.figure(figsize=(12,6))
plt.barh(top_10_movies['title'][::-1], top_10_movies['popularity'][::-1], color='pink')
plt.xlabel('Popularity')
plt.title('Top 10 Movies Berdasarkan Popularity')
plt.tight_layout()
plt.show()

"""**Insight :**

1. **Film paling populer** secara signifikan adalah **Minions** — dengan selisih yang **sangat besar** dibanding film lainnya. Ini menunjukkan bahwa film ini mendapat perhatian luar biasa dari audiens (kemungkinan dari anak-anak, keluarga, dan strategi promosi besar-besaran).

2. **Big Hero 6** menempati posisi ke-2, masih cukup jauh dibanding Minions, tapi jauh di atas posisi ke-3 (Pulp Fiction). Ini menunjukkan bahwa film animasi dari studio besar punya daya tarik populer yang kuat.

3. **Kombinasi genre** menarik perhatian:

   * Ada film **animasi dan keluarga** (Minions, Big Hero 6).
   * Film **aksi dan superhero** (The Dark Knight, Blade Runner, John Wick).
   * Film **drama dan klasik** (The Shawshank Redemption, Pulp Fiction).

4. **Film lama tetap bisa populer** — seperti *Pulp Fiction* dan *The Shawshank Redemption*. Ini menandakan bahwa faktor usia tidak selalu mengurangi popularitas jika film punya kualitas atau status "cult classic".

---

### Insight Tambahan

* **Popularitas ≠ Rating Tinggi**
  Beberapa film populer seperti *Minions* mungkin tidak memiliki rating tertinggi secara kritis, tapi tetap banyak ditonton karena **segmentasi pasar dan daya tarik massal**.

## **4. Data Preparation**

### a. Mengubah Dictionary menjadi String
"""

# Fungsi untuk memformat kolom 'genres' dari string menjadi format string genre yang dipisahkan tanda '|'
def format_genres(genre_string):
    # Tangani nilai NaN atau tipe data non-string
    if pd.isna(genre_string) or not isinstance(genre_string, str):
        return ""

    try:
        # Ubah string literal menjadi list of dict menggunakan ast.literal_eval
        parsed_genres = ast.literal_eval(genre_string)
    except (ValueError, SyntaxError) as e:
        # Jika parsing gagal, tampilkan peringatan dan kembalikan string kosong
        print(f"Warning: Tidak dapat parsing genre string '{genre_string}'. Error: {e}")
        return ""

    # Ambil nilai 'name' dari setiap dictionary dalam list dan gabungkan dengan delimiter '|'
    genre_names = [genre['name'] for genre in parsed_genres if 'name' in genre]
    return " | ".join(genre_names)

# Pilih kolom yang relevan dari DataFrame 'movies'
df = movies[['id', 'title']].copy()

# Terapkan fungsi format_genres ke kolom 'genres' dan simpan ke kolom baru
df['genres'] = movies['genres'].apply(format_genres)

# Susun ulang kolom dan ubah nama kolom 'id' menjadi 'movieId'
df = df[['id', 'title', 'genres']].rename(columns={'id': 'movieId'})

# Tampilkan 5 data teratas sebagai sampel
df.head()

"""**Insight :**

Data berhasil diubah dari format string kompleks menjadi format yang lebih sederhana dan mudah dipakai, dan disimpan dalam dataframe `df`.
"""

## Mengubah tipe data movieId menjadi string
df['movieId'] = df['movieId'].astype(str)
ratings['movieId'] = ratings['movieId'].astype(str)

df.info()
ratings.info()

"""**Insight :**

Kolom movieId pada dataframe df dan ratings diubah menjadi string.

### b. Merge Data
"""

movie_merged = pd.merge(ratings, df, on='movieId',how="inner")
movie_merged

"""**Insight :**

Data berhasil di merge berdasarkan kolom `movieId` dengan jumlah data 992 baris dan 6 kolom.

### c. Handle Missing Values
"""

movie_merged.isnull().sum()

"""**Insight :**

Tidak terdapat missing values.

### d. Handle Duplicated Data
"""

movie_merged.duplicated().sum()

"""**Insight :**

Tidak terdapat data duplicate

### e. Memecah genres yang dipisahkan oleh |
"""

genres = set()
for genres_str in movie_merged['genres']:
    if genres_str: # Only process non-empty strings
        for genre in genres_str.split(' | '):
            genres.add(genre.strip())

genres_list = list(genres)
print(genres_list)

"""**Insight :**

Kode ini mengambil semua genre unik dari kolom `genres` pada DataFrame `movie_merged`. Genre yang awalnya dipisah dengan `|` dipecah menjadi elemen terpisah, lalu dimasukkan ke dalam set agar tidak ada duplikat. Hasilnya adalah daftar genre unik yang ada di data.

# **Model Development dengan Content Based Features**

### a. TF-IDF Vectorizer
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tfidf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genres
tfidf.fit(movie_merged['genres'])

# Mapping array dari fitur index integer ke fitur nama
tfidf.get_feature_names_out()

"""**Insight:**

Ini adalah proses transformasi data teks pada kolom `genres` menjadi representasi numerik menggunakan teknik TF-IDF, yang bertujuan untuk mengetahui seberapa penting suatu genre (seperti 'action', 'drama', 'comedy', dll.) dalam keseluruhan kumpulan data film berdasarkan frekuensi kemunculannya secara proporsional.

"""

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tfidf.fit_transform(movie_merged['genres'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

"""**Insight:**

Data genre dari 992 film berhasil dikonversi menjadi matriks TF-IDF berukuran 992×22, yang menunjukkan bobot pentingnya masing-masing dari 22 genre untuk setiap film, sehingga memungkinkan analisis berbasis teks yang lebih numerik dan terukur.

"""

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan jenis genre
# Baris diisi dengan judul movie

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfidf.get_feature_names_out(),
    index=movie_merged.title
).sample(22, axis=1).sample(10, axis=0)

"""**Insight :**

Movie *The Dawn Patrol* memiliki genre *war*, movie *Turtles Can Fly* memiliki genre *drama*, movie *The Man Who Loved Woman* memiliki genre *comedy*.

TF-IDF berhasil membantu mengidentifikasi genre paling khas di tiap film.

### b. Cosine Similarity
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""**Insight :**

Matriks tersebut menunjukkan **kemiripan antar film berdasarkan genre** dalam bentuk nilai cosine similarity.

* Nilai 1 berarti film sangat mirip (biasanya terhadap dirinya sendiri).
* Nilai mendekati 0 berarti sangat tidak mirip.
* Contoh: jika baris ke-0 dan kolom ke-3 bernilai 0.56, artinya film 0 dan film 3 punya genre yang cukup mirip.

Singkatnya, ini dasar untuk sistem rekomendasi film berbasis genre.
"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto
cosine_sim_df = pd.DataFrame(cosine_sim, index=movie_merged['title'], columns=movie_merged['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""**Insight:**

Setiap sel menunjukkan seberapa mirip dua film berdasarkan TF-IDF genre-nya:

- Nilai 1 berarti film yang sama atau sangat mirip.

- Nilai mendekati 0 berarti tidak mirip.

Contoh: The Breakfast Club sangat mirip dengan Grill Point (1.0), artinya genre mereka identik.

Matriks ini bisa dipakai untuk mencari film yang mirip dengan film tertentu — cocok untuk sistem rekomendasi.
"""

def movie_recommendations(title, similarity=cosine_sim_df, items=movie_merged[['title', 'genres']], k=5):
    """
    Rekomendasi Movie berdasarkan kemiripan dataframe

    Parameter:
    ---
    title : tipe data string (str)
                Judul movie (index kemiripan dataframe)
    similarity : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan resto sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---

    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """

    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity.loc[:, title].to_numpy().argpartition(range(-1, -k, -1)).flatten()

    # Mengambil data dengan similarity terbesar dari index yang ada
    most_similiar = similarity.columns[index[-1:-(k+2):-1]]

    # Drop title agar nama resto yang dicari tidak muncul dalam daftar rekomendasi
    most_similiar = most_similiar.drop(title, errors='ignore')

    return pd.DataFrame(most_similiar).merge(items).head(k)

movie_merged[movie_merged.title.eq('Oliver Twist')]

movie_recommendations('Oliver Twist')

"""# **Problem Answers**

**1. Bagaimana cara merepresentasikan informasi genre film secara numerik agar bisa digunakan dalam perhitungan kemiripan antar film?**
"""

# Cek apakah TF-IDF berhasil transform genre jadi matriks numerik
try:
    # tf sudah TfidfVectorizer dari kode kamu
    tfidf_matrix = tfidf.fit_transform(movie_merged['genres'])
    print("TF-IDF matrix shape:", tfidf_matrix.shape)
    assert tfidf_matrix.shape[0] == movie_merged.shape[0], "Jumlah baris TF-IDF harus sama dengan jumlah film"
    print("Representasi genre ke numerik berhasil.")
except Exception as e:
    print("Error pada representasi genre:", e)

"""**Insight :**

TF-IDF berhasil mengubah genre film menjadi vektor numerik berdimensi (992, 22), artinya 992 film direpresentasikan oleh 22 genre unik. Representasi ini memungkinkan perhitungan kemiripan antar film berdasarkan bobot genre, dan jadi dasar utama untuk sistem rekomendasi content-based filtering.

**2. Bagaimana cara mengukur tingkat kemiripan antar film hanya berdasarkan informasi kontennya, khususnya genre?**
"""

# Tentukan dua judul film yang ingin dibandingkan
movie_1 = 'Men in Black II'
movie_2 = 'Jurassic Park'

# Ambil nilai similarity antara dua film tersebut
similarity_score = cosine_sim_df.loc[movie_1, movie_2]

# Konversi ke float kalau hasilnya satu sel DataFrame
if isinstance(similarity_score, pd.DataFrame):
    similarity_score = similarity_score.values[0][0]  # ambil nilai scalar
elif isinstance(similarity_score, pd.Series):
    similarity_score = similarity_score.values[0]

print(f"Similarity antara '{movie_1}' dan '{movie_2}': {similarity_score:.4f}")

"""**Insight :**

Dengan menghitung cosine similarity dari representasi TF-IDF genre, kita bisa mengukur seberapa mirip dua film berdasarkan kontennya. Nilai similarity **0.8289 **menunjukkan bahwa *Men in Black II* dan *Jurassic Park* memiliki genre yang sangat mirip berdasarkan representasi TF-IDF. Artinya, kedua film ini kemungkinan berbagi genre seperti action, adventure, atau sci-fi, sehingga dianggap sangat mirip oleh sistem content-based.

**c. Bagaimana cara mengembangkan sistem rekomendasi film yang mampu memberikan saran film sejenis hanya dari satu input judul film?**
"""

# Fungsi inputan dan rekomendasi film
def test_movie_recommendation():
    title_input = input("Masukkan judul film yang ingin direkomendasikan film miripnya: ")
    try:
        recommendations = movie_recommendations(title_input, k=5)
        print(f"\nRekomendasi film mirip dengan '{title_input}':\n")
        print(recommendations[['title', 'genres']])
    except KeyError:
        print(f"Judul film '{title_input}' tidak ditemukan dalam data.")

# Jalankan fungsi uji rekomendasi dengan inputan
test_movie_recommendation()

"""**Insight :**

Model berhasil memberikan rekomendasi film berdasarkan kemiripan genre.

Film seperti Saw II dan The Tunnel direkomendasikan karena memiliki genre yang serupa dengan Jurassic Park, seperti science fiction atau horror, sesuai dengan pendekatan content-based filtering. Ini menunjukkan bahwa sistem dapat menemukan film sejenis hanya dari input satu judul film.

# **Referensi**

- Adomavicius, G., & Tuzhilin, A. (2005). Toward the next generation of recommender systems: A survey of the state-of-the-art and possible extensions. IEEE Transactions on Knowledge and Data Engineering, 17(6), 734–749. https://doi.org/10.1109/TKDE.2005.99

- Lops, P., De Gemmis, M., & Semeraro, G. (2011). Content-based recommender systems: State of the art and trends. In F. Ricci, L. Rokach, B. Shapira, & P. B. Kantor (Eds.), Recommender Systems Handbook (pp. 73–105). Springer. https://doi.org/10.1007/978-0-387-85820-3_3

- Ricci, F., Rokach, L., & Shapira, B. (2011). Introduction to recommender systems handbook. In Recommender Systems Handbook (pp. 1–35). Springer. https://doi.org/10.1007/978-0-387-85820-3_1

- Aggarwal, C. C. (2016). Content-based recommender systems. In Recommender Systems: The Textbook (pp. 139–166). Springer. https://doi.org/10.1007/978-3-319-29659-3_5

- Banik, R. (2017). The Movies Dataset. Kaggle. https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset
"""