# -*- coding: utf-8 -*-
"""recommendation_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tm_l21EPYX_yT1kiOj8VTIONptBa40hH

# **Movies Recommendation System**

- **Nama**: Dewi Safira Permata sari
- **Email**: dwsafperri@gmail.com
- **ID Dicoding**: dwsafperri

# **Project Overview**

Dengan terus bertambahnya jumlah film yang tersedia di berbagai platform digital, pengguna sering kesulitan menemukan film yang sesuai dengan selera mereka. Salah satu pendekatan populer untuk mengatasi permasalahan ini adalah sistem rekomendasi berbasis konten (*content-based filtering*), di mana rekomendasi diberikan berdasarkan kesamaan karakteristik konten — dalam hal ini, genre film.

Proyek ini bertujuan membangun **sistem rekomendasi film berdasarkan genre** menggunakan pendekatan content-based filtering. Misalnya, jika seorang pengguna menyukai film King Kong, maka sistem akan merekomendasikan film lain yang memiliki genre serupa seperti Action, Adventure, atau Horror.

Sistem ini relevan karena membantu pengguna mengeksplorasi film yang mungkin belum pernah mereka tonton namun memiliki karakteristik yang mereka sukai. Selain itu, pendekatan ini tidak memerlukan data interaksi pengguna lain, sehingga cocok untuk kondisi cold start atau sistem baru.

# **Business Understanding**

## **Problem Statements**

1. Bagaimana cara merepresentasikan informasi genre film secara numerik agar bisa digunakan dalam perhitungan kemiripan antar film?

2. Bagaimana cara mengukur tingkat kemiripan antar film hanya berdasarkan informasi kontennya, khususnya genre?

3. Bagaimana cara mengembangkan sistem rekomendasi film yang mampu memberikan saran film sejenis hanya dari satu input judul film?

## **Goals**

1. Menghasilkan sistem rekomendasi film yang mampu menyarankan film lain dengan genre yang mirip dari input satu judul film.

2. Memudahkan pengguna menemukan film-film baru sesuai dengan preferensi genre mereka tanpa perlu memberikan penilaian eksplisit.

3. Membuat sistem yang bersifat general dan bisa digunakan tanpa ketergantungan pada data pengguna (user rating history).

## **Solution Statements**

1. Menggunakan pendekatan content-based filtering dengan teknik TF-IDF vectorization untuk merepresentasikan genre film.

2. Mengukur kemiripan antar film menggunakan cosine similarity untuk menentukan film-film yang memiliki kemiripan konten.

3. Mengimplementasikan fungsi rekomendasi yang menerima judul film sebagai input dan menghasilkan daftar rekomendasi berdasarkan tingkat kemiripan genre.

# **Data Understanding**

Tahap *Data Understanding* bertujuan untuk mengenal struktur, isi, dan karakteristik data yang akan digunakan. Dalam proyek ini, digunakan dua dataset utama dari [Kaggle - The Movies Dataset](https://www.kaggle.com/api/v1/datasets/download/rounakbanik/the-movies-dataset), yaitu `ratings.csv` dan `movies_metadata.csv`. Proses understanding mencakup membaca data, memeriksa struktur kolom dan tipe datanya, serta melakukan eksplorasi awal seperti statistik deskriptif untuk mengidentifikasi pola umum, missing values, dan anomali. Karena ukuran dataset cukup besar, dilakukan *sampling* sebanyak 10.000 baris untuk masing-masing file guna mempercepat proses eksplorasi dan pengolahan selanjutnya.

## **1. Import Library**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import ast

import warnings
warnings.filterwarnings('ignore')

"""## **2. Load Dataset**"""

#!/bin/bash
!curl -L -o the-movies-dataset.zip\
  'https://www.kaggle.com/api/v1/datasets/download/rounakbanik/the-movies-dataset'

!unzip -q the-movies-dataset.zip

"""### Deskripsi Variabel

"""

data_ratings = pd.read_csv("/content/ratings.csv")
data_ratings.info()

"""**Insight :**

Data ratings memiliki 26.024.289 baris dan 4 fitur.

| **Kolom**   | **Deskripsi**                                                                 |
| ----------- | ----------------------------------------------------------------------------- |
| `userId`    | ID pengguna yang memberikan rating.                                           |
| `movieId`   | ID film yang diberi rating.                                                   |
| `rating`    | Nilai rating yang diberikan oleh pengguna (biasanya skala 1.0–5.0).           |
| `timestamp` | Waktu pemberian rating dalam format Unix timestamp (jumlah detik sejak 1970). |
"""

data_movies = pd.read_csv("/content/movies_metadata.csv")
data_movies.info()

"""**Insight :**

Data movies memiliki 45.466 baris dan 24 kolom.

| **Kolom**               | **Deskripsi**                                             |
| ----------------------- | --------------------------------------------------------- |
| `adult`                 | Menandakan apakah film untuk dewasa (`True`/`False`).     |
| `belongs_to_collection` | Informasi jika film bagian dari seri/koleksi.             |
| `budget`                | Anggaran produksi film (biasanya dalam USD).              |
| `genres`                | Daftar genre film.                                        |
| `homepage`              | URL resmi film (jika tersedia).                           |
| `id`                    | ID unik film (dari TMDB).                                 |
| `imdb_id`               | ID film di IMDb.                                          |
| `original_language`     | Bahasa asli film (contoh: `en` untuk Inggris).            |
| `original_title`        | Judul asli film.                                          |
| `overview`              | Ringkasan atau sinopsis film.                             |
| `popularity`            | Skor popularitas dari TMDB.                               |
| `poster_path`           | Path ke poster film.                                      |
| `production_companies`  | Daftar perusahaan produksi.                               |
| `production_countries`  | Negara tempat film diproduksi.                            |
| `release_date`          | Tanggal rilis film.                                       |
| `revenue`               | Pendapatan film (dalam USD).                              |
| `runtime`               | Durasi film dalam menit.                                  |
| `spoken_languages`      | Bahasa yang digunakan dalam film.                         |
| `status`                | Status rilis film (misal: `Released`, `Post Production`). |
| `tagline`               | Slogan atau tagline film.                                 |
| `title`                 | Judul film (umumnya untuk keperluan tampilan).            |
| `video`                 | Apakah data ini berupa video (`True`/`False`).            |
| `vote_average`          | Rata-rata rating dari pengguna.                           |
| `vote_count`            | Jumlah total suara (rating) yang masuk.                   |
"""

print('Jumlah data ratings: ', len(data_ratings.userId.unique()))
print('Jumlah data movies yang direview: ', len(data_movies.id.unique()))

"""### Deskripsi Statistik"""

data_ratings.describe()

"""**Insight :**

| **Kolom**     | **Insight Utama**                                                                                                                                        |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **userId**    | - 10.000 data unik dengan userId rata-rata 135.302, rentang luas (8 – 270.761) <br> - Variasi user tinggi, artinya banyak user berbeda                   |
| **movieId**   | - Rentang sangat luas (1 – 174.615), rata-rata 16.095 <br> - Kuartil bawah jauh lebih kecil dari max, menunjukkan distribusi tidak merata (skewed)       |
| **rating**    | - Rata-rata 3.53 dengan rentang 0.5 – 5 <br> - Sebagian besar rating di 3 – 4 (median 3.5), menunjukkan rating cenderung positif                         |
| **timestamp** | - Rentang waktu cukup luas (sekitar 825 juta – 1,5 miliar UNIX timestamp) <br> - Distribusi waktu data merata, artinya pengambilan data berlangsung lama |

"""

data_movies.describe()

"""**Insight :**

| **Kolom**         | **Insight Utama**                                                                                                                                                                                                                                                                      |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **revenue**       | - Rata-rata sekitar 10.7 juta, tapi sangat bervariasi (std \~57 juta) <br> - 75% film punya revenue 0, artinya banyak film yang tidak menghasilkan pendapatan tercatat (atau nol) <br> - Maksimum sangat besar, mencapai 1,16 miliar, ada beberapa blockbuster saja yang sangat tinggi |
| **runtime**       | - Rata-rata durasi film sekitar 94 menit <br> - Rentang durasi cukup luas, dari 0 (mungkin data hilang/tidak valid) sampai 900 menit <br> - Kuartil menunjukkan mayoritas film berdurasi antara 85 sampai 107 menit                                                                    |
| **vote\_average** | - Rata-rata rating suara film 5.61 (skala 0–10) <br> - Sebagian besar film mendapat nilai sekitar 5–7 <br> - Nilai maksimum 10, nilai minimum 0 (mungkin film yang belum mendapat vote)                                                                                                |
| **vote\_count**   | - Rata-rata jumlah vote 107, tapi distribusi sangat skewed (std 464) <br> - Banyak film dengan vote rendah (kuartil 25% = 3), beberapa film sangat populer dengan hingga 12.269 vote                                                                                                   |

## **3. Exploratory Data Analysis**

Exploratory Data Analysis (EDA) dilakukan untuk memahami pola, anomali, serta hubungan antar fitur dalam dataset sebelum masuk ke tahap pemodelan. Dalam proses ini, dilakukan visualisasi distribusi data seperti rating film, tahun rilis, durasi, hingga korelasi antar fitur numerik. EDA juga membantu dalam pengambilan keputusan terhadap data mana yang perlu dibersihkan, difilter, atau dipertahankan.

### **a. Distribusi Rating**
"""

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8,4))
sns.histplot(data_ratings['rating'], bins=10, kde=True)
plt.title('Distribusi Rating Film')
plt.xlabel('Rating')
plt.ylabel('Frekuensi')
plt.show()

"""**Insight :**

Grafik tersebut menunjukkan distribusi rating film dalam dataset, dengan tambahan garis KDE (Kernel Density Estimation) yang menggambarkan bentuk distribusi secara halus. Terlihat bahwa sebagian besar rating berkumpul di sekitar angka 3 hingga 4, yang berarti mayoritas pengguna memberikan penilaian cukup positif terhadap film. Puncak-puncak tajam pada garis KDE menandakan adanya frekuensi tinggi pada nilai rating tertentu, seperti 3.0, 4.0, dan 5.0. Hal ini bisa disebabkan oleh kebiasaan pengguna memberikan rating bulat. Sementara itu, rating di bawah 2 terlihat jauh lebih jarang, mengindikasikan bahwa film dengan penilaian sangat rendah lebih sedikit jumlahnya atau jarang diberikan oleh pengguna. Grafik ini menunjukkan bahwa persebaran rating cenderung positif dengan sedikit outlier di sisi rating rendah.

### **b. Distribusi Tahun Rilis Film**
"""

data_movies['release_date'] = pd.to_datetime(data_movies['release_date'], errors='coerce')
data_movies['release_year'] = data_movies['release_date'].dt.year

plt.figure(figsize=(10,5))
sns.histplot(data_movies['release_year'].dropna().astype(int), bins=50)
plt.title('Distribusi Tahun Rilis Film')
plt.xlabel('Tahun Rilis')
plt.ylabel('Jumlah Film')
plt.show()

"""**Insight :**

Grafik tersebut menunjukkan distribusi jumlah film berdasarkan tahun rilisnya. Terlihat bahwa produksi film masih sangat sedikit sebelum tahun 1950, lalu mulai mengalami peningkatan secara bertahap setelahnya. Lonjakan yang signifikan terjadi sejak era 1990-an hingga mencapai puncaknya sekitar tahun 2010-an. Hal ini mencerminkan perkembangan industri perfilman global, baik dari sisi teknologi, permintaan pasar, maupun kemudahan produksi dan distribusi. Penurunan setelah tahun 2015 kemungkinan disebabkan oleh data yang belum lengkap atau keterbatasan koleksi dataset, bukan berarti produksi film benar-benar menurun secara drastis. Grafik ini menegaskan bahwa mayoritas film dalam dataset berasal dari dua dekade terakhir.

### **c. Distribusi Runtime**
"""

plt.figure(figsize=(8,4))
sns.histplot(data_movies['runtime'].dropna(), bins=50)
plt.title('Distribusi Durasi Film (menit)')
plt.xlabel('Durasi (menit)')
plt.ylabel('Jumlah Film')
plt.xlim(0, 250)  # Batasi sumbu X dari 0 sampai 250 menit
plt.show()

"""**Insight :**

1. Film paling umum berdurasi 90–100 menit.

2. Ada sejumlah kecil film yang sangat pendek atau panjang, tapi tidak mendominasi.

3. Durasi 0 kemungkinan perlu diperlakukan sebagai data tidak valid dalam analisis lanjutan.

### **d. Rating Rata-Rata per Film**
"""

avg_rating = data_ratings.groupby('movieId')['rating'].mean()

plt.figure(figsize=(8,4))
sns.histplot(avg_rating, bins=50, kde=True)
plt.title('Distribusi Rating Rata-rata per Film')
plt.xlabel('Rating Rata-rata')
plt.ylabel('Jumlah Film')
plt.show()

"""**Insight :**

  1. **Distribusi Berbentuk Mendekati Normal, Tapi Tidak Sempurna**

    * Sebagian besar film memiliki rating rata-rata antara **2.5 hingga 4.0**, yang merupakan kisaran "cukup hingga bagus".
    * Puncak distribusi ada di sekitar **rating 3.5–4.0**, menandakan banyak film mendapatkan respons positif dari penonton.

  2. **Pola Bar yang "Bergelombang"**

    * Ada lonjakan tajam di rating bulat seperti **3.0**, **4.0**, dan **5.0**.
    * Hal ini mengindikasikan:

      * Banyak penonton yang cenderung memberi rating bulat, bukan desimal.
      * Atau, rating rata-rata bulat terjadi karena banyak film memiliki jumlah rating sedikit.

  3. **Film dengan Rating Sangat Rendah (1.0–2.0) Relatif Sedikit**

    * Ini menunjukkan bahwa sangat sedikit film yang dianggap buruk secara universal.
    * Bisa juga disebabkan karena film yang sangat buruk tidak banyak ditonton/rated.

  4. **Ada Film dengan Rating Mendekati 5.0**

    * Menunjukkan bahwa ada beberapa film yang sangat disukai oleh penonton (cult classics atau masterpiece).

  5. **Skewness Tidak Terlalu Ekstrem**

    * Distribusi relatif simetris dengan kecenderungan sedikit ke kanan, artinya film cenderung mendapat nilai lebih tinggi daripada rendah.

### **e. Korelasi Antar Fitur Numerik Film**
"""

# Hitung jumlah rating per film
ratings_count = data_ratings.groupby('movieId').size().rename('rating_count')

# Hitung rata-rata rating per film
avg_rating = data_ratings.groupby('movieId')['rating'].mean().rename('average_rating')

# Gabungkan ke movies_metadata pakai 'movieId' (pastikan ada kolom yang sama)
movies_subset = data_movies[['id', 'runtime', 'release_year']].copy()
movies_subset['id'] = movies_subset['id'].astype(str)

# Convert movieId ke string agar bisa merge
ratings_count.index = ratings_count.index.astype(str)
avg_rating.index = avg_rating.index.astype(str)

# Gabungkan semua data
df_corr = movies_subset.set_index('id').join([ratings_count, avg_rating])

# Drop baris dengan nilai NaN
df_corr = df_corr.dropna()

df_corr.head()

import seaborn as sns
import matplotlib.pyplot as plt

# Hitung korelasi
corr = df_corr.corr()

plt.figure(figsize=(8,6))
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Korelasi Antar Fitur Numerik Film')
plt.show()

"""**Insight :**

* Semua fitur numerik memiliki **korelasi rendah (|r| < 0.2)**.
* Artinya: **tidak ada hubungan linear yang kuat** antar fitur numerik.
* Ini menunjukkan bahwa:

  * Popularitas (jumlah rating) **tidak selalu beriringan** dengan kualitas (rating rata-rata).
  * Durasi film **bukan indikator utama** apakah film disukai atau tidak.
  * Tahun rilis juga **bukan penentu utama** nilai atau popularitas film.

Tabel Interpretasi Korelasi

| Fitur 1        | Fitur 2          | Korelasi | Interpretasi                                                                                                      |
| -------------- | ---------------- | -------- | ----------------------------------------------------------------------------------------------------------------- |
| `runtime`      | `release_year`   | 0.09     | Korelasi sangat lemah dan positif — film modern cenderung sedikit lebih panjang durasinya, tapi tidak signifikan. |
| `runtime`      | `average_rating` | -0.06    | Korelasi sangat lemah dan negatif — durasi film **tidak berpengaruh signifikan** terhadap rating.                 |
| `release_year` | `average_rating` | 0.02     | Hampir tidak ada hubungan — film lama atau baru punya peluang yang sama untuk disukai.                            |
| `rating_count` | `average_rating` | 0.04     | Hampir tidak ada korelasi — banyaknya orang yang memberi rating **tidak menjamin film disukai**.                  |
| `runtime`      | `rating_count`   | 0.02     | Tidak ada hubungan berarti antara panjang film dan seberapa banyak orang menontonnya.                             |

---

### **f. Top 10 Movies Berdasarkan Popularity**
"""

import pandas as pd

data_movies['popularity'] = pd.to_numeric(data_movies['popularity'], errors='coerce')

# Drop data yang popularity-nya kosong
movies_clean = data_movies.dropna(subset=['popularity'])

# Urutkan berdasarkan popularity tertinggi dan ambil top 10
top_10_movies = movies_clean.sort_values(by='popularity', ascending=False).head(10)

# Plot bar chart
plt.figure(figsize=(12,6))
plt.barh(top_10_movies['title'][::-1], top_10_movies['popularity'][::-1], color='pink')
plt.xlabel('Popularity')
plt.title('Top 10 Movies Berdasarkan Popularity')
plt.tight_layout()
plt.show()

"""**Insight :**

1. **Minions** menjadi film **paling populer secara mencolok**, dengan selisih yang sangat besar dibandingkan film lainnya. Ini menunjukkan keberhasilan luar biasa dalam menjangkau audiens, kemungkinan karena:

   * Segmentasi keluarga dan anak-anak.
   * Visual animasi yang menarik.
   * Strategi pemasaran besar-besaran secara global.

2. **Wonder Woman** dan **Beauty and the Beast** menyusul di peringkat ke-2 dan ke-3 dengan popularitas yang cukup tinggi, namun **masih jauh di bawah Minions**. Ini menunjukkan minat besar pada genre **superhero dan fantasi-musikal**.

3. Beberapa film dalam daftar didominasi oleh genre:

   * **Animasi dan keluarga**: `Minions`, `Big Hero 6`.
   * **Aksi dan petualangan**: `Wonder Woman`, `John Wick`, `Baby Driver`, `Deadpool`, `Avatar`.
   * **Drama dan misteri**: `Gone Girl`.

4. Film **Gone Girl** menempati posisi ke-10, dengan popularitas yang lebih rendah dari yang lain, namun tetap masuk 10 besar — menunjukkan bahwa genre thriller psikologis juga punya daya tarik audiens.

* **Popularitas ≠ Rating Tertinggi**
  Popularitas menggambarkan seberapa banyak film ditonton atau dicari, bukan seberapa baik kualitasnya secara kritis.
  Contoh: *Minions* sangat populer, tapi belum tentu mendapatkan skor tinggi dari kritikus.

* **Faktor genre dan demografi** sangat mempengaruhi popularitas:
  Film yang ramah keluarga atau penuh aksi umumnya menjangkau lebih banyak penonton lintas usia dan budaya.

## **4. Data Preparation**

Sebelum dilakukan analisis atau pemodelan lebih lanjut, data perlu dibersihkan dan disiapkan. Tahapan ini meliputi konversi format data, merge antar tabel, mengatasi missing value, outlier, dan menyiapkan fitur agar siap dianalisis.

### a. Menentukan sample yang digunakan

Dikarenakan jumlah data yang terlalu banyak, maka data yang diambil hanya 10.000 data.
"""

ratings = data_ratings.sample(n=10000, random_state=42)
ratings.shape

"""**Insight :**

Data ratings berhasil di filter sebanyak 10.000 data.
"""

movies = data_movies.sample(n=10000, random_state=42)
movies.shape

"""**Insight :**

Data movies berhasil di filter sebanyak 10.000 data.

### b. Mengubah Dictionary menjadi String

Kode ini bertujuan untuk memilih kolom-kolom penting dari DataFrame `movies`, memformat data pada kolom `genres`, dan menyusun ulang data dalam format yang lebih bersih dan terstruktur untuk keperluan analisis lebih lanjut.

---

**Penjelasan Setiap Langkah**

1. **Fungsi `format_genres`**
   Fungsi ini mengubah data dalam kolom `genres` yang awalnya berbentuk string dari list of dictionary (misalnya: `"[{'id': 28, 'name': 'Action'}, {'id': 12, 'name': 'Adventure'}]"`) menjadi string biasa yang berisi nama-nama genre yang dipisahkan dengan tanda `|`, seperti:
   `"Action | Adventure"`.

2. **`df = movies[['id', 'title']].copy()`**
   Baris ini menyalin kolom `id` dan `title` dari DataFrame `movies`. Hanya kolom-kolom yang dianggap relevan yang diambil untuk diproses lebih lanjut.

3. **`df['genres'] = movies['genres'].apply(format_genres)`**
   Fungsi `format_genres` diterapkan ke kolom `genres` dalam DataFrame `movies`, kemudian hasilnya disimpan dalam kolom baru `genres` pada DataFrame `df`.

4. **Penyusunan Ulang dan Penggantian Nama Kolom**
   Kolom disusun ulang menjadi urutan `id`, `title`, dan `genres`, kemudian kolom `id` diubah namanya menjadi `movieId` untuk konsistensi dengan format umum pada sistem rekomendasi.
"""

# Fungsi untuk memformat kolom 'genres' dari string menjadi format string genre yang dipisahkan tanda '|'
def format_genres(genre_string):
    # Tangani nilai NaN atau tipe data non-string
    if pd.isna(genre_string) or not isinstance(genre_string, str):
        return ""

    try:
        # Ubah string literal menjadi list of dict menggunakan ast.literal_eval
        parsed_genres = ast.literal_eval(genre_string)
    except (ValueError, SyntaxError) as e:
        # Jika parsing gagal, tampilkan peringatan dan kembalikan string kosong
        print(f"Warning: Tidak dapat parsing genre string '{genre_string}'. Error: {e}")
        return ""

    # Ambil nilai 'name' dari setiap dictionary dalam list dan gabungkan dengan delimiter '|'
    genre_names = [genre['name'] for genre in parsed_genres if 'name' in genre]
    return " | ".join(genre_names)

# Pilih kolom yang relevan dari DataFrame 'movies'
df = movies[['id', 'title']].copy()

# Terapkan fungsi format_genres ke kolom 'genres' dan simpan ke kolom baru
df['genres'] = movies['genres'].apply(format_genres)

# Susun ulang kolom dan ubah nama kolom 'id' menjadi 'movieId'
df = df[['id', 'title', 'genres']].rename(columns={'id': 'movieId'})

# Tampilkan 5 data teratas sebagai sampel
df.head()

"""**Insight :**

Data berhasil diubah dari format string kompleks menjadi format yang lebih sederhana dan mudah dipakai, dan disimpan dalam dataframe `df`.

### **c. Mengubah tipe data `movieId` menjadi string**
"""

## Mengubah tipe data movieId menjadi string
df['movieId'] = df['movieId'].astype(str)
ratings['movieId'] = ratings['movieId'].astype(str)

df.info()
ratings.info()

"""**Insight :**

Kolom movieId pada dataframe df dan ratings diubah menjadi string.

### c. Merge Data
"""

movie_merged = pd.merge(ratings, df, on='movieId',how="inner")
movie_merged

"""**Insight :**

Data berhasil di merge berdasarkan kolom `movieId` dengan jumlah data 992 baris dan 6 kolom.

### d. Handle Missing Values
"""

movie_merged.isnull().sum()

"""**Insight :**

Tidak terdapat missing values.

### e. Handle Duplicated Data
"""

movie_merged.duplicated().sum()

"""**Insight :**

Tidak terdapat data duplicate

### f. Menangani Outlier dengan IQR Method
"""

movie_merged.describe()

# Mengganti Nilai Outlier dengan Batas Atas dan Batas Bawah Data

for i in movie_merged.select_dtypes(include='number'):
    Q1 = movie_merged[i].quantile(0.25)
    Q3 = movie_merged[i].quantile(0.75)
    IQR = Q3 - Q1

    maximum = Q3 + (1.5 * IQR)
    minimum = Q1 - (1.5 * IQR)

    movie_merged[i] = movie_merged[i].mask(movie_merged[i] > maximum, maximum)
    movie_merged[i] = movie_merged[i].mask(movie_merged[i] < minimum, minimum)

# Buat grid 3x3
fig, axes = plt.subplots(nrows=4, ncols=2, figsize=(12, 12))
fig.suptitle('Boxplot of Numerical Features', fontsize=16)

# Flatten axes supaya bisa di-loop
axes = axes.flatten()

# Loop fitur dan plot
numerical_feature = ['userId', 'rating', 'timestamp']
for i, feature in enumerate(numerical_feature):
    sns.boxplot(data=movie_merged, x=feature, ax=axes[i], color='skyblue')
    axes[i].set_title(f'{feature}')
    axes[i].set_xlabel('')

# Sembunyikan subplot yang tidak dipakai (jika jumlah fitur < jumlah grid)
for j in range(len(numerical_feature), len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout(rect=[0, 0, 1, 0.96])  # Agar tidak ketimpa judul
plt.show()

"""**Insight :**

| Fitur         | Insight                                                                                                                                                              |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **userId**    | Distribusi user cukup merata tanpa outlier. Semua nilai userId berada dalam rentang wajar (0–270k). Tidak ada titik ekstrem.                                         |
| **rating**    | Rentang rating hanya dari 0.5 hingga 5, dan sudah **tidak ada outlier**. Distribusi simetris dengan median sekitar 3.5. Artinya sistem rating berjalan sesuai skala. |
| **timestamp** | Distribusi waktu rating (dalam format Unix timestamp) juga sudah **tanpa outlier**. Data berkisar dari sekitar 2007 hingga 2017.                                     |

**Kesimpulan :**

* Penanganan outlier berhasil — tidak ada lagi nilai ekstrem atau titik individu terisolasi pada semua fitur numerik.
* Data siap digunakan untuk analisis atau modeling lebih lanjut karena sudah bersih dan stabil.

### g. Memecah genres yang dipisahkan oleh |
"""

genres = set()
for genres_str in movie_merged['genres']:
    if genres_str: # Only process non-empty strings
        for genre in genres_str.split(' | '):
            genres.add(genre.strip())

genres_list = list(genres)
print(genres_list)

"""**Insight :**

Kode ini mengambil semua genre dari kolom genres pada DataFrame movie_merged, di mana setiap entri genre dipisahkan oleh karakter ' | '. Fungsi .str.get_dummies(sep=' | ') memisahkan string genre berdasarkan delimiter tersebut, kemudian membuat kolom biner (dummy variables) untuk masing-masing genre yang unik.

Setiap kolom baru mewakili satu genre, dan nilainya 1 jika film tersebut memiliki genre tersebut, atau 0 jika tidak. Setelah itu, DataFrame dummy tersebut digabungkan kembali ke movie_merged dengan pd.concat() secara horizontal (axis=1), sehingga dataset kini memiliki representasi genre dalam bentuk numerik

### h. TF-IDF Vectorizer

Pertama-tama, informasi genre dari setiap film diubah menjadi representasi numerik menggunakan **TF-IDF (Term Frequency - Inverse Document Frequency)**. TF-IDF adalah teknik yang sering digunakan dalam pemrosesan teks untuk merepresentasikan seberapa penting suatu kata (dalam hal ini, genre) dalam suatu dokumen (film) dibandingkan dengan seluruh kumpulan dokumen (film-film lain).

* **Term Frequency (TF)** mengukur seberapa sering suatu genre muncul dalam data film tersebut.
* **Inverse Document Frequency (IDF)** menurunkan bobot genre yang terlalu umum (misalnya "drama" mungkin muncul di banyak film), sehingga genre yang lebih unik mendapat bobot lebih tinggi.

Hasil dari proses ini adalah **matriks TF-IDF**, di mana setiap baris merepresentasikan satu film dan setiap kolom mewakili satu genre. Nilai-nilai dalam matriks ini menunjukkan seberapa kuat keterkaitan film tersebut dengan masing-masing genre.

Langkah pertama adalah mengubah teks pada kolom `genres` menjadi representasi numerik menggunakan **TF-IDF (Term Frequency - Inverse Document Frequency)**. Proses ini bertujuan untuk mengetahui seberapa penting suatu genre (seperti *action*, *drama*, *comedy*, dll.) dalam keseluruhan kumpulan data film:
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tfidf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genres
tfidf.fit(movie_merged['genres'])

# Mapping array dari fitur index integer ke fitur nama
tfidf.get_feature_names_out()

"""**Insight:**

Ini adalah proses transformasi data teks pada kolom `genres` menjadi representasi numerik menggunakan teknik TF-IDF, yang bertujuan untuk mengetahui seberapa penting suatu genre (seperti 'action', 'drama', 'comedy', dll.) dalam keseluruhan kumpulan data film berdasarkan frekuensi kemunculannya secara proporsional.

"""

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tfidf.fit_transform(movie_merged['genres'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

"""**Insight:**

Data genre dari 992 film berhasil dikonversi menjadi matriks TF-IDF berukuran 992×22, yang menunjukkan bobot pentingnya masing-masing dari 22 genre untuk setiap film, sehingga memungkinkan analisis berbasis teks yang lebih numerik dan terukur.

"""

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan jenis genre
# Baris diisi dengan judul movie

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfidf.get_feature_names_out(),
    index=movie_merged.title
).sample(22, axis=1).sample(10, axis=0)

"""**Insight :**

Movie *The Perfect Storm* memiliki genre *war*, movie *Citizen Kane* memiliki genre *mystery*, movie *Indiana Jones and the Last Crusade* memiliki genre *adventure*.

TF-IDF berhasil membantu mengidentifikasi genre paling khas di tiap film.

# **Model Development dengan Content Based Features**

Untuk membangun sistem rekomendasi film berbasis konten, pendekatan yang digunakan adalah **content-based filtering**, yang merekomendasikan film berdasarkan kemiripan kontennya — dalam hal ini adalah **genre**. Langkah-langkah pengembangannya dijelaskan sebagai berikut:

---

**1. Penggunaan Cosine Similarity untuk Mengukur Kemiripan Antar Film**

Untuk membangun sistem rekomendasi berbasis konten, pendekatan yang digunakan adalah **content-based filtering**, di mana rekomendasi diberikan berdasarkan kemiripan konten antar item, dalam hal ini adalah **genre** film. Genre setiap film direpresentasikan dalam bentuk vektor menggunakan metode **TF-IDF (Term Frequency-Inverse Document Frequency)**. Vektor tersebut kemudian dibandingkan satu sama lain untuk mengukur tingkat kemiripan.

Ukuran kemiripan yang digunakan adalah **cosine similarity**, yang menghitung seberapa kecil sudut antara dua vektor dalam ruang multidimensi. Karakteristik dari cosine similarity:

* Nilainya berkisar dari **0** hingga **1**, di mana nilai **1** menunjukkan dua vektor sangat mirip atau identik, dan **0** berarti tidak ada kemiripan.
* Dalam konteks ini, dua film dianggap mirip jika genre-nya memiliki distribusi kata yang serupa dalam representasi TF-IDF-nya.

Dengan pendekatan ini, sistem dapat mengidentifikasi film-film yang paling relevan berdasarkan genre dari film input, kemudian menyarankan film-film yang memiliki konten paling mirip.

---

**2. Fungsi `movie_recommendations()` untuk Menghasilkan Rekomendasi**

Fungsi `movie_recommendations()` bertanggung jawab untuk menghasilkan daftar rekomendasi film berdasarkan hasil perhitungan cosine similarity. Berikut adalah penjelasan alur kerja dari fungsi tersebut:

* **Parameter yang digunakan**:

  * `title`: Judul film yang dijadikan referensi awal untuk mencari kemiripan.
  * `similarity`: Matriks cosine similarity antar film, di mana nilai di dalamnya menunjukkan tingkat kemiripan antara setiap pasangan film.
  * `items`: DataFrame yang berisi informasi film (judul dan genre).
  * `top_n`: Jumlah film yang ingin direkomendasikan.

* **Langkah-langkah dalam fungsi**:

  1. Mengecek apakah judul film input tersedia dalam kolom matriks similarity. Jika tidak ditemukan, fungsi akan menghentikan proses dengan menampilkan error.
  2. Menentukan batas maksimum rekomendasi (`top_n`), disesuaikan agar tidak melebihi jumlah film dalam dataset.
  3. Mengambil indeks film-film dengan nilai cosine similarity tertinggi terhadap film input menggunakan metode `argpartition` — pendekatan ini efisien untuk pencarian elemen terbesar.
  4. Menghapus film itu sendiri dari hasil rekomendasi agar tidak direkomendasikan ke pengguna.
  5. Menggabungkan hasil rekomendasi dengan DataFrame `items` untuk menampilkan informasi judul dan genre film.
  6. Mengembalikan `top_n` film yang paling mirip sebagai hasil rekomendasi.

Dengan demikian, fungsi ini menjadi inti dari sistem rekomendasi berbasis konten yang mengandalkan kemiripan genre untuk menyarankan film-film relevan kepada pengguna.

### a. Cosine Similarity

Setelah setiap film direpresentasikan sebagai vektor TF-IDF, langkah berikutnya adalah mengukur tingkat kemiripan antar film. Untuk ini digunakan **cosine similarity**, yaitu ukuran kesamaan antara dua vektor berdasarkan sudut di antara mereka.

* Nilai cosine similarity berkisar antara **0** (tidak mirip sama sekali) hingga **1** (sangat mirip).
* Dua film dianggap mirip jika genre-nya memiliki distribusi yang serupa dalam representasi TF-IDF mereka.

Dengan menggunakan cosine similarity, sistem dapat mencari film yang paling dekat (mirip) vektornya dengan film input, dan merekomendasikannya ke pengguna. Setiap film direpresentasikan dalam bentuk vektor yang menggambarkan genre-genre yang dimiliki, kemudian dihitung sudut kosinus antara vektor-vektor tersebut untuk menentukan seberapa mirip kedua film tersebut secara genre.
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""**Insight :**

Matriks tersebut menunjukkan **kemiripan antar film berdasarkan genre** dalam bentuk nilai cosine similarity.

* Nilai 1 berarti film sangat mirip (biasanya terhadap dirinya sendiri).
* Nilai mendekati 0 berarti sangat tidak mirip.
* Contoh: jika baris ke-0 dan kolom ke-3 bernilai 0.56, artinya film 0 dan film 3 punya genre yang cukup mirip.

"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa judul movie
cosine_sim_df = pd.DataFrame(cosine_sim, index=movie_merged['title'], columns=movie_merged['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap movie
cosine_sim_df.sample(5, axis=1).sample(20, axis=0)

"""**Insight:**

Setiap sel menunjukkan seberapa mirip dua film berdasarkan TF-IDF genre-nya:

- Nilai 1 berarti film yang sama atau sangat mirip.

- Nilai mendekati 0 berarti tidak mirip.

Berdasarkan matriks similarity yang ditampilkan, film *The Machinist* memiliki nilai kemiripan tertinggi dengan film *Tough Enough	* sebesar 1.0, yang menunjukkan kesamaan genre atau fitur lainnya yang sangat kuat antara kedua film tersebut.

## **b. Movie Recommendation Function**

Fungsi berikut dibuat untuk menghasilkan rekomendasi film berdasarkan judul film yang dimasukkan. Proses utama yang terjadi di fungsi ini adalah:

1. **Validasi Judul Film Input**
   Fungsi mulai dengan memastikan film yang kamu masukkan sebagai referensi (`title`) ada di dalam data cosine similarity matrix. Kalau gak ada, fungsi langsung kasih error supaya kamu tahu film itu tidak tersedia untuk rekomendasi.

2. **Penentuan Jumlah Rekomendasi yang Realistis**
   Fungsi membatasi jumlah film rekomendasi yang akan dikembalikan supaya tidak melebihi jumlah film yang ada di data (dikurangi 1 karena film yang direferensikan gak masuk rekomendasi).

3. **Mencari Film yang Paling Mirip dengan Film Referensi**
   Fungsi menggunakan metode `argpartition` pada array nilai similarity untuk menemukan film-film yang memiliki skor kemiripan tertinggi dengan film referensi. Metode ini lebih efisien daripada mengurutkan semua nilai similarity.

4. **Mengambil Judul Film Film yang Paling Mirip**
   Setelah menemukan indeks film-film dengan skor kemiripan tertinggi, fungsi mengambil judul film-film tersebut dari kolom matrix similarity.

5. **Menghapus Film Referensi dari Daftar Rekomendasi**
   Film referensi tidak dimasukkan ke dalam rekomendasi karena sudah pasti sama dengan film yang jadi acuan.

6. **Menggabungkan Data Film dengan Info Genre**
   Fungsi menggabungkan judul film-film yang direkomendasikan dengan data film asli (`items`) supaya hasil rekomendasi gak cuma judul, tapi juga menampilkan genre film.

7. **Mengembalikan Data Frame Rekomendasi**
   Fungsi mengembalikan sebuah DataFrame yang berisi film-film rekomendasi (judul dan genre) sebanyak `top_n` film yang paling mirip.
"""

def movie_recommendations(title, similarity=cosine_sim_df, items=movie_merged[['title', 'genres']], top_n=5):
    """
    Rekomendasi movie berdasarkan kemiripan genre menggunakan cosine similarity.

    Parameters:
    - title (str): Judul film yang dijadikan referensi.
    - similarity (DataFrame): Matrix cosine similarity antar film.
    - items (DataFrame): Dataframe berisi informasi judul dan genre film.
    - top_n (int): Jumlah rekomendasi film yang dihasilkan.

    Returns:
    - DataFrame: Rekomendasi film beserta genrenya.
    """
    if title not in similarity.columns:
        raise ValueError(f"Title '{title}' tidak ditemukan di similarity matrix.")

    # Batas maksimum rekomendasi yang masuk akal (tidak termasuk dirinya sendiri)
    top_n = min(top_n, similarity.shape[0] - 1)

    # Cari index film paling mirip (dengan argpartition untuk efisiensi)
    index = similarity.loc[:, title].to_numpy().argpartition(range(-1, -top_n-1, -1)).flatten()
    most_similar = similarity.columns[index[-1:-(top_n+2):-1]]

    # Hapus film itu sendiri dari hasil rekomendasi
    most_similar = most_similar.drop(title, errors='ignore')

    return (
        pd.DataFrame(most_similar, columns=['title'])
        .merge(items.drop_duplicates('title'), on='title')
        .head(top_n)
    )

cosine_sim_df = cosine_sim_df[~cosine_sim_df.index.duplicated(keep='first')]

movie_merged[movie_merged.title.eq('Man\'s Favorite Sport?')]

movie_recommendations('Man\'s Favorite Sport?')

movie_recommendations('Beauty and the Beast', top_n = 10)

"""**Insight :**

Tabel ini berisi daftar film beserta genre-nya yang bisa digunakan sebagai dasar untuk sistem rekomendasi film berbasis genre. Dengan menggunakan *top\_n = 10*, artinya sistem akan merekomendasikan 10 film paling mirip berdasarkan kesamaan genre dengan film referensi. Genre campuran seperti “Adventure | Science Fiction” atau “Drama | Action | Thriller” menunjukkan bahwa film-film ini bisa memiliki overlap genre yang kompleks, sehingga cosine similarity dapat menangkap tingkat kemiripan yang lebih detail daripada hanya mencocokkan genre tunggal. Ini memungkinkan rekomendasi yang lebih relevan dan beragam bagi pengguna.

# **Kelebihan dan Kekurangan Content-Based Filtering**

## Kelebihan

1. **Personalisasi tinggi**

   Rekomendasi disesuaikan dengan preferensi unik setiap pengguna berdasarkan item yang pernah mereka sukai.
   *Contoh:* Jika seorang pengguna menyukai film *Inception* karena bergenre Sci-Fi dan Thriller, maka sistem akan merekomendasikan film seperti *Interstellar* atau *Tenet* yang memiliki genre serupa.

2. **Tidak butuh data dari pengguna lain**

   Sistem hanya mengandalkan informasi dari item (misalnya genre film), sehingga cocok digunakan saat jumlah pengguna masih sedikit (*cold start for user*).
   *Contoh:* Sistem tetap bisa bekerja meski hanya ada satu pengguna karena cukup melihat genre film yang disukai.

3. **Tahan terhadap serangan manipulasi user**

   Karena tidak bergantung pada rating dari banyak pengguna, sistem ini relatif aman dari spam atau rating palsu.
   *Contoh:* Tidak terpengaruh jika ada banyak akun palsu yang memberi rating tinggi ke film tertentu.

## Kekurangan

1. **Rekomendasi cenderung sempit (kurang variatif)**

   Hanya merekomendasikan item yang sangat mirip, sehingga pengguna bisa merasa terjebak dalam "filter bubble".
   *Contoh:* Jika pengguna suka film horor, sistem hanya akan merekomendasikan horor terus-menerus, meskipun mungkin ia juga akan suka thriller atau mystery.

2. **Sulit menangkap selera kompleks**

   Jika preferensi pengguna mencakup banyak genre atau aspek lain (seperti sutradara atau alur cerita), pendekatan ini bisa kurang fleksibel.
   *Contoh:* Seorang pengguna menyukai *The Dark Knight* bukan hanya karena genre-nya, tapi juga karena sutradaranya (Christopher Nolan), namun sistem hanya melihat genre "Action" dan "Crime".

3. **Ketergantungan pada representasi fitur konten**

   Jika fitur kontennya tidak lengkap atau tidak akurat, maka kualitas rekomendasinya akan menurun.
   *Contoh:* Jika informasi genre sebuah film tidak ditulis lengkap, maka sistem tidak bisa memberikan rekomendasi yang tepat.

# **Evaluation**

Untuk menilai kinerja dari model **content-based filtering** dalam sistem rekomendasi film ini, digunakan tiga metrik utama yang berbasis relevansi, yaitu **Precision\@k**, **Recall\@k**, dan **F1-Score\@k**. Ketiga metrik ini umum digunakan dalam evaluasi sistem rekomendasi karena dapat mengukur seberapa tepat dan lengkap rekomendasi yang diberikan.

1. **Precision\@k**
   Precision\@k mengukur seberapa banyak item yang benar-benar relevan di antara *k item* teratas yang direkomendasikan oleh sistem. Metrik ini menggambarkan **tingkat akurasi** rekomendasi.

$$
\text{Precision@k} = \frac{\text{Jumlah item relevan dalam rekomendasi}}{k}
$$

2. **Recall\@k**
   Recall\@k menunjukkan sejauh mana sistem berhasil menemukan item yang relevan dari seluruh item relevan yang ada. Artinya, metrik ini menilai **cakupan** dari sistem rekomendasi.

$$
\text{Recall@k} = \frac{\text{Jumlah item relevan dalam rekomendasi}}{\text{Jumlah total item relevan}}
$$

3. **F1-Score\@k**
   F1-Score\@k merupakan kombinasi dari Precision dan Recall dalam bentuk rata-rata harmonik. Metrik ini digunakan untuk menilai **keseimbangan antara ketepatan dan kelengkapan** dalam hasil rekomendasi.

$$
\text{F1-Score@k} = \frac{2 \times \text{Precision@k} \times \text{Recall@k}}{\text{Precision@k} + \text{Recall@k}}
$$
"""

# data ground truth (film relevan yang disukai user)
ground_truth = {
    "Live and Let Die": {"The Getaway", "Dr. Jekyll and Mr. Hyde", "Big Fish"},
}

def evaluate_recommendation(ground_truth, k=5):
    precision_list = []
    recall_list = []
    f1_list = []

    for title, relevant_set in ground_truth.items():
        # Ambil rekomendasi film dari fungsi kamu
        recommended_df = movie_recommendations(title, top_n=k)
        recommended = set(recommended_df['title'])

        true_positives = recommended & relevant_set

        precision = len(true_positives) / k if k > 0 else 0
        recall = len(true_positives) / len(relevant_set) if len(relevant_set) > 0 else 0
        if precision + recall == 0:
            f1 = 0
        else:
            f1 = 2 * precision * recall / (precision + recall)

        precision_list.append(precision)
        recall_list.append(recall)
        f1_list.append(f1)

    print(f"Average Precision@{k}: {sum(precision_list)/len(precision_list):.2f}")
    print(f"Average Recall@{k}: {sum(recall_list)/len(recall_list):.2f}")
    print(f"Average F1-Score@{k}: {sum(f1_list)/len(f1_list):.2f}")
    print("Relevant Movies :", list(true_positives))

evaluate_recommendation(ground_truth, k=5)

"""**Insight :**

- **Precision@5 sebesar 0.60** menunjukkan bahwa dari lima film yang direkomendasikan oleh sistem, rata-rata tiga film di antaranya merupakan film yang relevan atau sesuai dengan preferensi pengguna. Dengan kata lain, 60% rekomendasi yang diberikan tepat sasaran.

- **Recall@5 sebesar 1.00** mengindikasikan bahwa semua film yang dianggap relevan (berdasarkan data ground truth) berhasil direkomendasikan oleh sistem dalam lima rekomendasi teratas. Ini menunjukkan bahwa sistem memiliki kemampuan yang sangat baik dalam menemukan semua item relevan yang tersedia.

- **F1-Score@5 sebesar 0.75** merupakan nilai rata-rata harmonik dari precision dan recall, yang mencerminkan keseimbangan yang baik antara ketepatan dan kelengkapan rekomendasi yang diberikan oleh sistem.

# **Problem Answers**

**1. Bagaimana cara merepresentasikan informasi genre film secara numerik agar bisa digunakan dalam perhitungan kemiripan antar film?**
"""

# Cek apakah TF-IDF berhasil transform genre jadi matriks numerik
try:
    # tf sudah TfidfVectorizer dari kode kamu
    tfidf_matrix = tfidf.fit_transform(movie_merged['genres'])
    print("TF-IDF matrix shape:", tfidf_matrix.shape)
    assert tfidf_matrix.shape[0] == movie_merged.shape[0], "Jumlah baris TF-IDF harus sama dengan jumlah film"
    print("Representasi genre ke numerik berhasil.")
except Exception as e:
    print("Error pada representasi genre:", e)

"""**Insight :**

TF-IDF berhasil mengubah genre film menjadi vektor numerik berdimensi (992, 22), artinya 992 film direpresentasikan oleh 22 genre unik. Representasi ini memungkinkan perhitungan kemiripan antar film berdasarkan bobot genre, dan jadi dasar utama untuk sistem rekomendasi content-based filtering.

**2. Bagaimana cara mengukur tingkat kemiripan antar film hanya berdasarkan informasi kontennya, khususnya genre?**
"""

# Tentukan dua judul film yang ingin dibandingkan
movie_1 = 'Men in Black II'
movie_2 = 'Jurassic Park'

# Ambil nilai similarity antara dua film tersebut
similarity_score = cosine_sim_df.loc[movie_1, movie_2]

# Konversi ke float kalau hasilnya satu sel DataFrame
if isinstance(similarity_score, pd.DataFrame):
    similarity_score = similarity_score.values[0][0]  # ambil nilai scalar
elif isinstance(similarity_score, pd.Series):
    similarity_score = similarity_score.values[0]

print(f"Similarity antara '{movie_1}' dan '{movie_2}': {similarity_score:.4f}")

"""**Insight :**

Dengan menghitung cosine similarity dari representasi TF-IDF genre, kita bisa mengukur seberapa mirip dua film berdasarkan kontennya. Nilai similarity **0.8289** menunjukkan bahwa *Men in Black II* dan *Jurassic Park* memiliki genre yang sangat mirip berdasarkan representasi TF-IDF. Artinya, kedua film ini kemungkinan berbagi genre seperti action, adventure, atau sci-fi, sehingga dianggap sangat mirip oleh sistem content-based.

**c. Bagaimana cara mengembangkan sistem rekomendasi film yang mampu memberikan saran film sejenis hanya dari satu input judul film?**
"""

# Fungsi inputan dan rekomendasi film
def test_movie_recommendation():
    title_input = input("Masukkan judul film yang ingin direkomendasikan film miripnya: ")
    try:
        recommendations = movie_recommendations(title_input, top_n=5)
        print(f"\nRekomendasi film mirip dengan '{title_input}':\n")
        print(recommendations[['title', 'genres']])
    except KeyError:
        print(f"Judul film '{title_input}' tidak ditemukan dalam data.")

# Jalankan fungsi uji rekomendasi dengan inputan
test_movie_recommendation()

"""**Insight :**

Model berhasil memberikan rekomendasi film berdasarkan kemiripan genre.

Film seperti Grill Point, Tough Enough, dan Big Fish direkomendasikan karena memiliki genre yang serupa, seperti Drama, Adventure, atau Thriller, sesuai dengan pendekatan content-based filtering. Ini menunjukkan bahwa sistem dapat menemukan film sejenis hanya dari input satu judul film.

# **Referensi**

* Ricci, F., Rokach, L., & Shapira, B. (2011). Introduction to recommender systems handbook. In *Recommender Systems Handbook* (pp. 1–35). Springer. [https://doi.org/10.1007/978-0-387-85820-3\_1](https://doi.org/10.1007/978-0-387-85820-3_1)

* Aggarwal, C. C. (2016). Content-based recommender systems. In *Recommender Systems: The Textbook* (pp. 139–166). Springer. [https://doi.org/10.1007/978-3-319-29659-3\_5](https://doi.org/10.1007/978-3-319-29659-3_5)

* Banik, R. (2017). *The Movies Dataset*. Kaggle. [https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset](https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset)
"""